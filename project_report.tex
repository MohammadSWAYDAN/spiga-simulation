\documentclass[a4paper,12pt]{report}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[french]{babel}
\usepackage{graphicx}
\usepackage{geometry}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{color}
\usepackage{float}
\usepackage{tikz}
\usetikzlibrary{shapes.geometric, arrows, positioning}

% Configuration de la mise en page
\geometry{hmargin=2.5cm,vmargin=2.5cm}

% Configuration pour le code Java
\definecolor{javared}{rgb}{0.6,0,0}
\definecolor{javagreen}{rgb}{0.25,0.5,0.35}
\definecolor{javapurple}{rgb}{0.5,0,0.35}
\definecolor{javadocblue}{rgb}{0.25,0.35,0.75}

\lstset{
  language=Java,
  basicstyle=\ttfamily\small,
  keywordstyle=\color{javapurple}\bfseries,
  stringstyle=\color{javared},
  commentstyle=\color{javagreen},
  morecomment=[s][\color{javadocblue}]{/**}{*/},
  numbers=left,
  numberstyle=\tiny\color{black},
  stepnumber=1,
  numbersep=10pt,
  tabsize=4,
  showspaces=false,
  showstringspaces=false,
  frame=single,
  breaklines=true
}

\title{\textbf{Rapport de Projet Final : Simulation SPIGA}\\
\large Système de Pilotage Intelligent et Gestion d'Actifs}
\author{
    \textbf{Équipe de Projet} \\
    \\
    [Nom Étudiant 1] \\
    [Nom Étudiant 2] \\
    [Nom Étudiant 3]
}
\date{\today}

\begin{document}

\maketitle
\tableofcontents
\newpage

\chapter{Introduction et Cahier des Charges}

\section{Contexte et Objectifs}
Ce projet a été réalisé dans le cadre du cours de Programmation Orientée Objet (POO) en Java (2025-2026). L'objectif pédagogique était de concevoir et implémenter une simulation complexe mettant en œuvre les piliers de la POO (Encapsulation, Héritage, Polymorphisme, Abstraction) tout en maîtrisant le développement d'interfaces graphiques modernes avec JavaFX.

\section{Analyse du Cahier des Charges}
Le système SPIGA doit simuler une flotte de drones et de véhicules marins autonomes. Les contraintes imposées et respectées sont les suivantes :
\begin{itemize}
    \item \textbf{Multimodalité} : Gestion simultanée d'actifs aériens (Drones), de surface (Navires) et sous-marins.
    \item \textbf{Temps Réel} : La simulation doit tourner à 60 images par seconde (FPS) via une boucle de jeu (Game Loop).
    \item \textbf{Environnement} : Prise en compte d'obstacles physiques et de conditions météorologiques variables.
    \item \textbf{Interactivité} : L'utilisateur doit pouvoir interagir avec la simulation (ajouter des drones, changer la météo, zoomer) sans interrompre le processus.
\end{itemize}

\chapter{Architecture Logicielle}

Nous avons opté pour une architecture stricte \textbf{MVC (Modèle-Vue-Contrôleur)}. Ce choix est justifié par la nécessité de séparer la logique de simulation (complexe) de son rendu graphique.

\section{Diagramme d'Architecture (MVC)}

\begin{center}
\begin{tikzpicture}[node distance=2cm]
\tikzstyle{block} = [rectangle, rounded corners, minimum width=3cm, minimum height=1cm,text centered, draw=black, fill=blue!10]
\tikzstyle{arrow} = [thick,->,>=stealth]

\node (model) [block] {\textbf{Modèle (Core)}\\ SimulationService, Actifs};
\node (view) [block, below of=model, xshift=-4cm] {\textbf{Vue (UI)}\\ MapCanvas, FXML};
\node (controller) [block, below of=model, xshift=4cm] {\textbf{Contrôleur}\\ MainController};
\node (user) [draw, circle, minimum size=1cm, below of=controller, yshift=-1.5cm] {User};

\draw [arrow] (controller) -- node[anchor=south] {Mise à jour} (model);
\draw [arrow] (model) -- node[anchor=south] {État (Polling)} (controller);
\draw [arrow] (controller) -- node[anchor=south] {Redessine} (view);
\draw [arrow] (user) -- node[anchor=east] {Events (Clics)} (controller);
\end{tikzpicture}
\end{center}

\section{Justification des Choix Architecturaux}

\subsection{Pourquoi ségréger le Core (Modèle) ?}
Le package \texttt{com.spiga.core} ne contient \textbf{aucune} référence à JavaFX.
\begin{itemize}
    \item \textbf{Justification} : Cela permet de tester la logique métier (Tests Unitaires JUnit) sans avoir besoin de lancer l'interface graphique. Cela rend aussi le code portable (ex: portage vers un serveur web backend possible).
\end{itemize}

\subsection{Gestion du Temps (AnimationTimer)}
Nous utilisons \texttt{javafx.animation.AnimationTimer} pour la boucle principale.
\begin{itemize}
    \item \textbf{Justification} : Contrairement à un \texttt{Thread.sleep()} classique qui est imprécis, \texttt{AnimationTimer} est synchronisé avec le taux de rafraîchissement de l'écran (V-Sync), garantissant une fluidité parfaite à 60 FPS sans déchirement d'image.
\end{itemize}

\chapter{Conception Orientée Objet (Détails)}

\section{Hiérarchie des Classes (Diagramme)}

\begin{center}
\begin{tikzpicture}[node distance=1.5cm]
\tikzstyle{class} = [rectangle, draw=black, fill=yellow!10, text centered, minimum width=3cm]
\tikzstyle{inherit} = [thick, ->, >=open triangle 60]

\node (mobile) [class] {\textbf{ActifMobile} (Abstract)};
\node (air) [class, below of=mobile, xshift=-3cm] {\textbf{ActifAerien}};
\node (sea) [class, below of=mobile, xshift=3cm] {\textbf{ActifMarin}};
\node (drone) [class, below of=air] {DroneReconnaissance};
\node (sub) [class, below of=sea] {VehiculeSousMarin};

\draw [inherit] (air) -- (mobile);
\draw [inherit] (sea) -- (mobile);
\draw [inherit] (drone) -- (air);
\draw [inherit] (sub) -- (sea);
\end{tikzpicture}
\end{center}

\section{Application des Concepts Clés}

\subsection{1. Abstraction}
\textbf{Usage :} La classe \texttt{ActifMobile} est abstraite.
\textbf{Justification :} Un "Actif Mobile" générique n'existe pas physiquement. On ne doit pas pouvoir instancier un objet qui n'est ni un avion, ni un bateau. L'abstraction nous permet de définir un socle commun (position x, y, z, id) sans permettre la création d'objets incomplets.

\subsection{2. Polymorphisme}
\textbf{Usage :} La liste unique \texttt{List<ActifMobile>} dans \texttt{GestionnaireEssaim}.
\textbf{Justification :} Le moteur de simulation parcourt cette liste et appelle \texttt{deplacer()} sur chaque élément. Grâce au polymorphisme, si l'élément est un Drone, il volera. Si c'est un Sous-marin, il plongera. Le code appelant n'a pas besoin de savoir le type exact, ce qui rend le code \textbf{extensible} (Open/Closed Principle).

\lstset{caption={Exemple de Polymorphisme dans SimulationService.java}}
\begin{lstlisting}
for (ActifMobile actif : flotte) {
    // Appel polymorphique : la methode executee depend du type reel de l'objet
    actif.deplacer(dt); 
}
\end{lstlisting}

\subsection{3. Encapsulation}
\textbf{Usage :} Tous les attributs sont \texttt{private} ou \texttt{protected}, accessibles via des Getters/Setters.
\textbf{Justification :} Protège l'intégrité des données. Par exemple, la méthode \texttt{setAltitude()} d'un drone vérifie si l'altitude demandée ne dépasse pas \texttt{altitudeMax}. Un accès public direct aurait permis de mettre des valeurs incohérentes.

\chapter{Nouvelles Fonctionnalités et Innovations}

\section{Système de Météo Dynamique}
Nous avons implémenté un singleton \texttt{Weather} qui affecte globalement la simulation.
\begin{itemize}
    \item \textbf{Impact Technique} : La méthode \texttt{getConsommation()} est surchargée dans chaque sous-classe pour réagir différemment à la météo (un sous-marin est moins affecté par le vent qu'un drone).
\end{itemize}

\section{Double Vue (Top-Down et Profil)}
L'ajout d'une vue de profil (\texttt{SideViewCanvas}) permet de visualiser la dimension Z (Altitude/Profondeur) qui est invisible sur la carte 2D.
\begin{itemize}
    \item \textbf{Défi Technique} : Il a fallu implémenter une projection orthogonale où l'axe Y de l'écran représente l'axe Z du monde, avec une inversion de signe (car en informatique, Y=0 est en haut).
\end{itemize}

\chapter{Garanties de Qualité et Optimisation}

\section{Plan de Tests}
Nous avons validé notre application selon deux axes :
1.  \textbf{Tests Unitaires} : Validation de la logique de déplacement et de consommation hors interface graphique.
2.  \textbf{Tests d'Intégration} : Vérification que le contrôleur met correctement à jour la vue.

\section{Optimisation des Performances}
\begin{itemize}
    \item \textbf{Usage de Canvas} : Plutôt que de créer un nœud JavaFX (Circle, Rectangle) pour chaque drone (ce qui est lourd pour le Scene Graph), nous redessinons tout sur un seul \texttt{Canvas} à chaque frame. C'est la technique utilisée dans les jeux vidéo pour supporter des milliers d'entités.
\end{itemize}

\chapter{Organisation et Méthodologie}

\section{Planning et Répartition}
\begin{itemize}
    \item \textbf{Semaine 1} : Analyse UML et création squelette Core.
    \item \textbf{Semaine 2} : Implémentation JavaFX de base (MapCanvas).
    \item \textbf{Semaine 3} : Logique métier (Missions, Gestionnaire).
    \item \textbf{Semaine 4} : Finitions, Javadoc et Rapport.
\end{itemize}

\section{Collaboration}
Utilisation d'outils de versionning (Git) pour fusionner nos travaux respectifs sur les packages \texttt{ui}, \texttt{core}, et \texttt{management}.

\chapter{Conclusion}
Le projet SPIGA est une démonstration complète d'une application Java moderne. Il combine une architecture rigoureuse, une interface utilisateur réactive et une logique métier extensible. Les choix techniques effectués garantissent que le logiciel est prêt pour de futures évolutions, comme l'ajout de la 3D réelle ou d'une IA plus poussée.

\end{document}
